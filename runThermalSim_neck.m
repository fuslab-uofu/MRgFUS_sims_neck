% =============================================================================%               runThermalSim_neck()% -----------------------------------------------------------------------------%% Description:  Function for running a thermal simulation using the _____%               %               Transforms the given target to HAS coordinates, runs HAS, then %               finds the max pressure voxel, max Q voxel, target voxel pressure, %               target voxel Q, and distance between target and max voxels.%% Authors:      Michelle Kline & Marta M. Iversen  %               Department of Radiology and Imaging Sciences  %               University of Utah  %% Inputs:       1. segmented neck model (3D, integers >= 1)%               2. model resolution ([size row, size col, size page], mm)%               3. power deposition ('Q')%               4. desired target (struct with 'coordsRCP' and 'id')%               5. power scale factor (factor * 100W)%               6. temperature required for success%               7. length of simulation (s)%               8. bool flag - calculate thermal dose %               % Output:       1. temperatures ('T', °C, 4D)%               2. thermal dose (°C, 3D)%               3. Vector of structs with results for each simulation:%                   'timePoints'        - %                   'maxT'              - %                   'maxT_RCP'          - %                   'hotVoxTemps'       - %                   'targetVoxTemps'    - %                   'hotVolTemps'       - %                   'targetVolTemps'    - %                   'averageMediaT'     - %                   'failureToHeat'     - %% Requirements: MATLAB R2020a or later (toolboxes?)  %% Dependencies: 1. runCalcTemps_Neck%               % =============================================================================                                    function [T, TDose, results] = runThermalSim_neck(Modl, resolution, Q, targetRCP, QScaleFactor, reqTemp, tEnd, calc_TDose)        %% run the simulation    % Initialize arrays and set parameters    % temperature initial condition. Will need to be altered and updated if applied in a full treatment plan    temps_ic = single(zeros(size(Modl)));     Vox = resolution/1000; % in m    % thermal properties are defined for the following media:    % 1 == water     % 2 == bone/spine    % 3 == skin    % 4 == spinal cord    % 5 == blood vessels    % 6 == fat    % 7 == muscle    % 8 == other - neck    % thermal conductivity (W/m*C, nominal)    k = [0.60 0.31 0.37 0.51 0.52 0.21 0.49 0.50];    % density (kg/m3, nominal)    rho = [1000 1908 1109 1075 1050 911 1090 937];    % specific heat (J/kg*K, nominal)    sp = [4178 2274 3391 3630 3617 2348 3421 3200];    % perfusion (kg/m3*s)    w = [0 1.82 2.17 3.08 183.7 0.457 0.732 0.6];    % watts for the sonication, Q scaling factor    % in this case, HAS used 100 W to create Q    Qsf = QScaleFactor;        % calculate simulation time interval for stability    A = Vox(1)/Vox(2);   % dimensionless increment    B = Vox(1)/Vox(3);   % dimensionless increment    w_max = max(w);    rho_min = min(rho);    c_min = min(sp);    k_max = max(k);    % maximum allowable time step before iterations become unstable (s)    dt_max = 1/(w_max/rho_min+2*k_max*(1+A^2+B^2)/(rho_min*c_min*Vox(1)^2));     % max temporal spacing (seconds)    dt_max = (floor(dt_max*100))/100;          % Model simulated temperatures    % INPUTS: Modl, initial condition for temps, Voxel size, time increment,    % heating time (s), cooling time (s), density, thermal conductivity,    % specific heat, perfusion type (1==uniform in tissue type), perfusion, Q    % pattern (W/m3), #FZ, time save interval, arterial    % temp (typically == 0°C), BC type (1==adiabatic)    [T, results.timePoints]=Calc_TEMPS_v04S(Modl,temps_ic,Vox,dt_max,tEnd,0,rho,k,sp,1,w,Q*Qsf,1,dt_max*10,0,0);        %% ANALYSIS    % gather some information about hottest voxel and target voxel    % what is the highest temperature and where is the hottest voxel at the last measurement?    finalTemps = T(:,:,:,end);    maxTemp = max(finalTemps(:));    maxVoxLinear = find(finalTemps() == maxTemp);    [maxTempRCP(1), maxTempRCP(2), maxTempRCP(3)] = ind2sub(size(finalTemps), maxVoxLinear);    results.maxT = maxTemp;    results.maxT_RCP = maxTempRCP;    % what were the temps at that hottest voxel during previous measurements?    results.hotVoxTemps = zeros(size(results.timePoints));    for t = 1:length(results.timePoints)        results.hotVoxTemps(t) = T(maxTempRCP(1), maxTempRCP(2), maxTempRCP(3),t);    end    % what is the temperature at the target voxel at the last measurement?    results.targetT = finalTemps(targetRCP(1), targetRCP(2), targetRCP(3));        % compute euclidean distance between max voxel and target voxel    results.distT = sqrt( (maxTempRCP(1)-targetRCP(1))^2 * resolution(1) + ...        (maxTempRCP(2)-targetRCP(2))^2 * resolution(2) + (maxTempRCP(3)-targetRCP(3))^2 * resolution(3));        % what were the temps at the target voxel during previous measurements?    targetVoxTemps = zeros(size(results.timePoints));    safety = zeros(size(results.timePoints));    requiredTemp = zeros(size(results.timePoints));    sixty = zeros(size(results.timePoints));    for t = 2:length(results.timePoints)        targetVoxTemps(t) = T(targetRCP(1),targetRCP(2),targetRCP(3), t);        safety(t) = 8;        requiredTemp(t) = reqTemp;        sixty(t) = 60;    end    results.targetVoxTemps = targetVoxTemps;     % what is the average temperature in a 10x10x10 mm volume around the target?    % volume around the hottest voxel?    % size of volume    sizeVolume_mm = [10 10 10];%     sizeVolume_RCP = round((sizeVolume_mm.*resolution_RCP)/2); % convert with resolution, convert to radius, round    sizeVolume_RCP = [4 2 4]; % for 129    indicesVolume_RCP.R = targetRCP(1)-sizeVolume_RCP(1):targetRCP(1)+sizeVolume_RCP(1);    indicesVolume_RCP.C = targetRCP(2)-sizeVolume_RCP(2):targetRCP(2)+sizeVolume_RCP(2);     indicesVolume_RCP.P = targetRCP(3)-sizeVolume_RCP(3):targetRCP(3)+sizeVolume_RCP(3);    indicesVolumeHot_RCP.R = maxTempRCP(1)-sizeVolume_RCP(1):maxTempRCP(1)+sizeVolume_RCP(1);    indicesVolumeHot_RCP.C = maxTempRCP(2)-sizeVolume_RCP(2):maxTempRCP(2)+sizeVolume_RCP(2);     indicesVolumeHot_RCP.P = maxTempRCP(3)-sizeVolume_RCP(3):maxTempRCP(3)+sizeVolume_RCP(3);    % volume over time    results.targetVolTemps = zeros(size(results.timePoints));    results.hotVolTemps = zeros(size(results.timePoints));    for t = 1:length(results.timePoints)        results.targetVolTemps(t) = mean(T(indicesVolume_RCP.R, indicesVolume_RCP.C, indicesVolume_RCP.P,t),'all');        results.hotVolTemps(t) = mean(T(indicesVolumeHot_RCP.R, indicesVolumeHot_RCP.C, indicesVolumeHot_RCP.P,t),'all');    end        % what is the average temperature in the different model media?    numMedia = length(unique(Modl));    finalTempsThresh = finalTemps .* (finalTemps > 0);    results.averageMediaT = zeros(numMedia, 2);     results.averageMediaT(:,1) = 1:numMedia;    for medium = 1:numMedia         results.averageMediaT(medium,2) = mean(mean(finalTempsThresh(Modl==medium)));    end        % define failure as target does not get above    if (results.targetT < reqTemp)        results.failureToHeat = 1;    else        results.failureToHeat = 0;    end        % optionally calculate thermal dose    TDose = [];    baseTemp = 37;    topTemp = 43;    if (calc_TDose == true)        dt = mean(diff(results.timePoints));        tempsabs = (T(:,:,:,1:2:end)+baseTemp);        R = zeros(size(tempsabs));         R(tempsabs < topTemp) = 4;         R(tempsabs >= topTemp) = 2;         R(tempsabs < baseTemp) = 0.0;            dose = R.^(tempsabs - topTemp);                   TDose = dt*(1/60)*trapz(dose,4);    end  end   