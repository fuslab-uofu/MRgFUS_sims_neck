% =============================================================================%               runAcousticSim_neck()% -----------------------------------------------------------------------------%% Description:  Run an acoustic simulation on a model of the human neck using %               the hybrid angular spectrum (HAS) method.%               Runs HAS, then finds the max pressure voxel, max Q voxel, target voxel  %               pressure, target voxel Q, and distance between target and max voxels.%% Authors:      Michelle Kline & Marta M. Iversen  %               Department of Radiology and Imaging Sciences  %               University of Utah  %% Inputs:       1. simulated pressure source ('ERFA') files for A10 and bone transducers%               2. the focal length of the transducer (m)%               3. segmented neck model (3D, integers >= 1)%               4. model resolution ([size row, size col, size page], mm)%               5. desired target [row, col, page]%               6. rotation angle of transducer (degrees)%               7. electronic steering ([x, y, z], mm)%               % Output:       1. pressure ('P', MPa, 3D complex singles)%               2. power deposition ('Q', W/M^3, 3D doubles)%               3. Vector of structs with results for each simulation:%                   'maxP'      - maximum pressure%                   'maxP_RCP'  - max pressure voxel indices%                   'targetP'   - pressure at target voxel%                   'distP'     - Euclidean distance, target voxel to max pressure voxel%                   'maxQ'      - maximum Q %                   'maxQ_RCP'  - max Q voxel indices%                   'targetQ'   - Q at target voxel%                   'distQ'     - Euclidean distance, target voxel to max Q voxel%                   'metadata'  - HAS-related metadata%% Requirements: MATLAB R2020a or later (toolboxes?)  %% Dependencies: 1. calcHAS()%               2. plotPQSlice()%               3. SteeringPhasesPA8()%               4. rotvolpivrecenter()%               5. rotvolpivrecenterinterp()%               6. rotcoordpiv()%               % =============================================================================function [P, Q, results] = runAcousticSim_neck(ERFA, focalLen, Modl, resolution, target, psi, steering)    %% PREPARE SIMULATION PARAMETERS    % Translate desired target rcp to xyz    % targeting in HAS is in terms of distance (mm) offset from center of model    centerIdx_x = round(size(Modl,2)/2);     centerIdx_y = round(size(Modl,1)/2);    targetX = target(2); % col    targetY = target(1); % row    targetZ = target(3); % page    pivotIndices = [targetX, targetY, targetZ];        % calculate offsets from center of model    t1_offsetIdx_x = targetX - centerIdx_x;     t1Offsetx = t1_offsetIdx_x * resolution(2);    t1_offsetIdx_y = targetY - centerIdx_y;     t1Offsety = t1_offsetIdx_y * resolution(1);    t1_mm = targetZ * resolution(3);    t1offsetz = focalLen - t1_mm;             % translate desired steering from rcp to xyz (m)    steerX = steering(2)/1000;    steerY = steering(1)/1000;    steerZ = steering(3)/1000;    steeringXYZ = [-steerX, -steerY, steerZ]; % FIXME        % move transducer offsets if electronic steering (mm)    t1Offsetx = t1Offsetx + steerX*1000;    t1Offsety = t1Offsety + steerY*1000;    t1offsetz = t1offsetz + steerZ*1000;        rotationThetaPsi = [0, psi]; % no theta rotation for this study    % required files for HAS    addpath(genpath('HAS'));    %% RUN HAS    ERFA.Pr = 100;	% acoustic power output of transducer (units)	    % Model parameters --------------------------------------------------------------------------------    model.Modl = Modl;    clear Modl;    % ----- media properties -----    % c = speed of sound in (m/s)      model.c0 = 1500;       % speed of sound in water (m/s)    model.cVector(1)=1500;       % water     model.cVector(2)=2000;       % bone/spine    model.cVector(3)=1624.0;     % skin    model.cVector(4)=1542.0;     % spinal cord    model.cVector(5)=1578.2;     % blood vessels    model.cVector(6)=1440.2;     % fat    model.cVector(7)=1588.4;     % muscle    % model.cVector(8)=1480;       % other - neck    model.cVector(8)=1504.5;     % csf      model.c = model.cVector(model.Modl);  % generate 3D property matrix for speed of sound    % a = pressure attenuation coefficient (Np/cm*MHz) (NOTE UNITS!)    model.aVector(1)=0.000;       % water     model.aVector(2)=0.54553;     % bone/spine    model.aVector(3)=0.21158;     % skin    model.aVector(4)=0.68911;     % spinal cord    model.aVector(5)=0.023676;    % blood vessels    model.aVector(6)=0.043578;    % fat    model.aVector(7)=0.071088;    % muscle    % model.aVector(8)=0.086;       % other - neck    model.aVector(8)=0.001;       % csf    model.a = model.aVector(model.Modl);  % generate 3D property matrix for attenuation    % aabs = pressure absorption coefficient [= att - scatt] in (Np/cm*MHz)    % rho =  density in (kg/m^3)    model.rho0 = 1000;     % density of water    model.rhoVector(1)=1000;     % water     model.rhoVector(2)=1908;     % bone/spine    model.rhoVector(3)=1109;     % skin    model.rhoVector(4)=1075;     % spinal cord    model.rhoVector(5)=1050;     % blood vessels    model.rhoVector(6)=911;      % fat    model.rhoVector(7)=1090;     % muscle    % model.rhoVector(8)=937;     % other - neck    model.rhoVector(8)=1007;     % csf    model.rho = model.rhoVector(model.Modl); % generate 3D property matrix for density    % randvc = the std dev of all parameters associated with each medium    % (statistical scattering Approach C).    model.randvcVector(1)=0.000; % water     model.randvcVector(2)=0.000; % bone/spine    model.randvcVector(3)=0.000; % skin    model.randvcVector(4)=0.000; % spinal cord    model.randvcVector(5)=0.000; % blood vessels    model.randvcVector(6)=0.000; % fat    model.randvcVector(7)=0.000; % muscle    model.randvcVector(8)=0.000; % other - neck    model.randvcVector(9)=0.000; % csf    model.randvc = model.randvcVector(model.Modl);        model.aabs = model.a;        model.parameters.corrl = 10;    % 10 indices    % ----- other model parameters -----    model.Dx = resolution(1);	% resolution in 2nd MATLAB dimension (x/col)    model.Dy = resolution(2);	% resolution in 1st MATLAB dimension (y/row)    model.Dz = resolution(3);	% resolution in 3rd MATLAB dimension (z/pag)        % Positioning parameters --------------------------------------------------------------------------    % ----- mechanical positioning (mechanical offset from center of model) -----    positioning.offsetxmm = t1Offsetx;     % ...along 2nd MATLAB dimension(mm)    positioning.offsetymm = t1Offsety;     % ...along 1st MATLAB dimension(mm)    positioning.dmm = t1offsetz;    % distance from transducer base to model base (mm)    % ----- electronic steering (*** NOTE: calls outside function ***) -----    positioning.h = steeringXYZ(1);     % ... in x-direction (along 2nd MATLAB dimension) (m)    positioning.v = steeringXYZ(2);     % ... in y-direction (alond 1st MATLAB dimension) (m)    positioning.z = steeringXYZ(3);     % ... in z-direction (along 3rd MATLAB dimension) (m)    ang=SteeringPhasesPA8(positioning.v, positioning.h, positioning.z, ERFA.R, ERFA.ElemLoc, ERFA.fMHz*1e6, model.c0);    positioning.angpgvect = shiftdim((exp(-1i * ang))', -1);    clear ang        % Number of reflections ---------------------------------------------------------------------------    numberOfReflections = 1;        % Steering correction?    if any(steeringXYZ)        pivotIndices(1) = pivotIndices(1) - round(positioning.h*1000 / model.Dx);        pivotIndices(2) = pivotIndices(2) - round(positioning.v*1000 / model.Dy);    end        % Here is where we optionally rotate the model ----------------------------------------------------    if any(rotationThetaPsi)        disp("Rotating...")        notRotatedModel = model.Modl;        model.Modl = rotvolpivrecenter(model.Modl, pivotIndices, model.Dx, model.Dy, model.Dz, rotationThetaPsi(1), rotationThetaPsi(2));        % NOTE: after rotating the model, you must redefine the corresponding 3D property matrices.        model.c = model.cVector(model.Modl);        model.a = model.aVector(model.Modl);        model.aabs = model.a;        model.rho = model.rhoVector(model.Modl);        model.randvc = model.randvcVector(model.Modl);        % In HAS, rotating the model automatically sets the geometric focus to be the rotation pivot        % point. Therefore, we must clear the transducer positioning offsets        positioning.offsetxmm = 0;          positioning.offsetymm = 0;    end        %% HAS    % now that inputs are constructed, call calcHAS()    disp("Running HAS...");    [Q, results.maxQ, P, results.maxP] = calcHAS(ERFA, model, positioning, numberOfReflections);        % rotate back    if any(rotationThetaPsi)        disp("Rotating back...")        model.Modl = notRotatedModel;        P = rotvolpivrecenterinterp(P, pivotIndices, model.Dx, model.Dy, model.Dz, rotationThetaPsi(1), rotationThetaPsi(2), 0);        Q = rotvolpivrecenterinterp(Q, pivotIndices, model.Dx, model.Dy, model.Dz, rotationThetaPsi(1), rotationThetaPsi(2), 0);        % interpolation during rotation may cause maxQ and maxpout to change. Refresh.        results.maxQ = max(Q(:));        results.maxP = max(abs(P(:)));    end          % save the variables used with this simulation for future reference    metadata.ERFA = ERFA;    metadata.ERFA = rmfield(metadata.ERFA, 'perfa'); % too big to store in metadata    metadata.model = model;    fields = {'Modl','c','a','rho','randvc','aabs'}; % too big to store in metadata    metadata.model = rmfield(metadata.model,fields);    metadata.model.mediaDescription = '1=water, 2=bone/spine, 3=skin, 4=spinal cord, 5=blood vessels, 6=fat, 7=muscle, 8=csf' ;     metadata.positioning = positioning;    metadata.numberOfReflections = numberOfReflections;    results.metadata = metadata;    %% ANALYSIS    % get pressure, Q, and indices of max P and max Q voxels    results.maxQ_RCP = zeros(1,3);    linearIndQ = find(Q == results.maxQ);    [results.maxQ_RCP(1), results.maxQ_RCP(2), results.maxQ_RCP(3)] = ind2sub(size(Q), linearIndQ);        results.maxP_RCP = zeros(1,3);    linearIndP = find(abs(P) == results.maxP);    [results.maxP_RCP(1), results.maxP_RCP(2), results.maxP_RCP(3)] = ind2sub(size(P), linearIndP);    % get pressure and Q values at target voxel    results.targetQ = Q(targetY, targetX, targetZ);    results.targetP = abs(P(targetY, targetX, targetZ));    % compute euclidean distance between max voxel and target voxel    results.distQ = sqrt( (results.maxQ_RCP(1)-target(1))^2 * resolution(1) + ...        (results.maxQ_RCP(2)-target(2))^2 * resolution(2) + ...        (results.maxQ_RCP(3)-target(3))^2 * resolution(3) );    results.distP = sqrt( (results.maxP_RCP(1)-target(1))^2 * resolution(1) + ...        (results.maxP_RCP(2)-target(2))^2 * resolution(2) + ...        (results.maxP_RCP(3)-target(3))^2 * resolution(3) );    end   