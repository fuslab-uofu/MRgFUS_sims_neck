% Main calculation function for the Urvi Vyas and Douglas Christensen Hybrid Angular Spectrum % (HAS) ultrasound beam propagation simulation algorithm.% HAS is copyright: D.A. Christensen 2019	% Notes:% The HAS algorithm was developed as an interactive MATLAB GUI. However, the need arose to run HAS  % simulations in batch, without user interaction, from the command line or from a script. % I pulled the main simulation code from the CalcHAS_ERFA8f.m workspace script to create this CalcHAS() % function. GUI-related variables and code were removed, but the algorithm is the same. The only % difference between the CalcHAS() (non-GUI) and CalcHAS_ERFA8f.m algorithm is that% CalcHAS() expects the model's acoustic properties to be 3D matrices of the same dimensions as the % model. This allows for continuous properties instead of a discrete, one-property-to-one-medium % correspondence.% Suggested usage:% Before calling CalcHAS(), set up all of the parameters for the simulation (see Inputs below). % If you are doing phase aberration correction and/or electronic steering, these phases should be  % stored in "angpgvect". If you want the simulated transducer to be angled, you must first rotate % the model ("Modl") as well as it's corresponding property matrices, run CalcHAS(), then rotate% the model and property matrices back. % Inputs:% 1) ERFA parameters struct. %    The element response function array (ERFA) is the simulated transducer. It should have the following fields:%    ElemLoc      element locations            %    Len          size of the ERFA plane                    %    R            transducer radius of curvature               %    dxp          incremental size of steps in ERFA plane (in m)               %    dyp          incremental size of steps in ERFA plane (in m)                 %    fMHz         transducer frequency                 %    isPA         is this a phased array? (true/false)                %    perfa        pressure on the ERFA plane       %    pfilename    name of file containing ERFA parameters                %    relem        radius of circular element of array transducer, if applicable (m)            %    sx           distance between the transducer and the ERFA plane     %    Pr           acoustic power output of transducer%    erfafilenm   the ERFA file used to create the phases% 2) model parameters struct.%    The model structure represents the simulation space, including the segmented 3-D %    model, acoustic properties, etc. It should have the following fields:%    Modl         the model (3D matrix of integers representing media types)%    c0           speed of sound in water (m/s)%    c            3D matrix of speed of sound values (m/s)%    a            3D matrix of total attenuation values%    aabs         3D pressure absorption coefficient (optional)%    rho0         density of water%    rho          3D matrix of density values%    Dx           model resolution in 2nd dimension (mm)%    Dy           model resolution in 1st dimension (mm)%    Dz           model resolution in 3rd dimension (mm)%    modlfilenm   the model file used to create the phases%    randvc       random variation (the std dev of all parameters associated with each medium, %                 for statistical scattering Approach C).% 3) positioning parameters struct. %    This describes the mechanical and electronic steering of the simulated transducer.%    It should have the following fields:%    offsetxmm    mechanical offset from center of Modl (along 2nd MATLAB dimension) (mm)%    offsetymm    mechanical offset from center of Modl (along 1st MATLAB dimension) (mm)%    dmm          distance from transducer base to Modl base (mm)%    angpgvect    steering phases or correction phases% 4) numrefl      number of reflections desired (integer, >= 0)% Outputs:% 1) Q            power deposition pattern (3D matrix of )% 2) maxQ% 3) pout         pressure pattern (3D matrix of complex singles)% 4) maxpout% Michelle Kline% UCAIR, Department of Radiology and Imaging Sciences% December 2020%   07/2024, Michelle Kline, DAC:%       Correct frequency scaling in alpha and beta calculations to (mmax*dx) and (lmax*dy) instead of lx and ly. %       Also update alpha and beta calcs to allow even model sizing.%       Look for "07/2024"function [Q, maxQ, pout, maxpout] = calcHAS(erfaParams, modelParams, positioningParams, numrefl)     %% pre-initialization ==========================================================================    % define outputs    Q =[];    maxQ = 0;    pout = [];    maxpout = 0;        %% check inputs =================================================================================    if nargin ~= 4 || ~isstruct(erfaParams) || ~isstruct(modelParams) || ~isstruct(positioningParams)        disp('Usage: [Q, maxQ, pout, maxpout] = calcHAS(erfaParams, modelParams, positioningParams, numrefl)');        return;    end        %% argument validation =========================================================================    % if aabs field not present, use attenuation (a)    if ~isfield(modelParams,'aabs')        modelParams.aabs=modelParams.a;     end    % grab all of the fields in erfaParams and compare to list of expected fields    % ugly, but 'contains' command is not available pre-R2016b    expectedErfaFields = {'ElemLoc'; 'Len'; 'R'; 'dxp'; 'dyp'; 'fMHz'; 'isPA'; 'perfa'; 'pfilename'; 'relem'; 'sx'; 'Pr'};    actualErfaFields = fieldnames(erfaParams);    for iterator = 1:length(expectedErfaFields)        index = strfind(actualErfaFields,expectedErfaFields{iterator});        if isempty(find(not(cellfun('isempty',index)),1))             disp(['Error: missing parameter: erfaParams.' expectedErfaFields{iterator}]);            return;        end    end    expectedModelFields = {'Modl'; 'c0'; 'c'; 'a'; 'rho0'; 'rho'; 'Dx'; 'Dy'; 'Dz'; 'randvc'};    actualModelFields = fieldnames(modelParams);    for iterator = 1:length(expectedModelFields)        index = strfind(actualModelFields,expectedModelFields{iterator});        if isempty(find(not(cellfun('isempty',index)),1))            disp(['Error: missing parameter: modelParams.' expectedModelFields{iterator}]);            return;        end    end    expectedPositioningFields = {'offsetxmm'; 'offsetymm'; 'dmm'; 'angpgvect'};    actualPositioningFields = fieldnames(positioningParams);    for iterator = 1:length(expectedPositioningFields)        index = strfind(actualPositioningFields,expectedPositioningFields{iterator});        if isempty(find(not(cellfun('isempty',index)),1))             disp(['Error: missing parameter: positioningParams.' expectedPositioningFields{iterator}]);            return;        end    end     % check 3D property matrix dimensions     %   total attenuation    if size(modelParams.a) ~= size(modelParams.Modl)        disp('modelParams.a (attenuation) must be the same dimensions as modelParams.Modl');        return;    end    %   pressure absorption coefficient    if size(modelParams.aabs) ~= size(modelParams.Modl)        disp('modelParams.aabs must be the same dimensions as modelParams.Modl');        return;    end    %   speed of sound (no random variation in it now)    if size(modelParams.c) ~= size(modelParams.Modl)        disp('modelParams.c must be the same dimensions as modelParams.Modl');        return;    else        if min(min(min(modelParams.c)))==0            disp('Some speed of sound values (modelParams.c) are zero');            return;         end    end    % density    if size(modelParams.rho) ~= size(modelParams.Modl)        disp('modelParams.rho must be the same dimensions as modelParams.Modl');        return;    end    %% initialization ==============================================================================        % convert pressure absorption coefficient units from [Np/cm*MHz] to [Np/m], assume linear in f [in MHz].    absmodl = modelParams.aabs*1e2*erfaParams.fMHz;         % frequency in Hz    f = erfaParams.fMHz*1e6;	    % always use single precision perfa, to save memory    if strcmp(class(erfaParams.perfa),'double')  %#ok<STISA>        erfaParams.perfa=single(erfaParams.perfa);     end     % size of ERFA plane    [lmaxerfa,mmaxerfa,~] = size(erfaParams.perfa);     % sample spacing in ERFA plane, in m    Dyerfa = (erfaParams.Len(1)/(lmaxerfa-1)) * 1000;     Dxerfa = (erfaParams.Len(2)/(mmaxerfa-1)) * 1000;     % setting up axes in mm units for interpolation    yaxiserfa = Dyerfa*(-(lmaxerfa-1)/2:(lmaxerfa-1)/2);        xaxiserfa = Dxerfa*(-(mmaxerfa-1)/2:(mmaxerfa-1)/2);     % adjust axes for offsets, all in mm    xaxiserfaoffs = xaxiserfa+positioningParams.offsetxmm;     yaxiserfaoffs = yaxiserfa+positioningParams.offsetymm;           % size of model    % The size of the model (lmax,mmax,nmax) sets the size of the simulation    % space.  lmax and y are vertical; mmax and x are horizontal. NOTE: Be aware of the (y,x,z) order of arrays    % assumed here.  Therefore lmax by mmax is also the y by x size of the pressure pattern pp on the front    % plane of the modelParams.Modl, interpolated from perfa. Note: lmax and mmax should be ODD numbers to keep    % fftshift symmetrical, with the dc term at exact center of spectrum.    [lmax,mmax,nmax] = size(modelParams.Modl);          % axes (between centers of end points) for interpolation.    xaxisinterp = modelParams.Dx*(-(mmax-1)/2:(mmax-1)/2); % (mm)    yaxisinterp = modelParams.Dy*(-(lmax-1)/2:(lmax-1)/2); % (mm)       % longitudinal axis has full Dz at the center of the first voxel, since HAS calculates    % travel through a full distance Dz for each voxel and attributes the resulting pressure     % to that voxel.    % MMKline: unused?%     lx = ((mmax-1) * modelParams.Dx)/1000; % note conversion from mm to m%     ly = ((lmax-1) * modelParams.Dy)/1000; % note conversion from mm to m       if Dyerfa>modelParams.Dy || Dxerfa>modelParams.Dx        disp(['Warning: the sample spacing on the ERFA plane is more than that of the model. '...            'Should use a higher resolution ERFA file.']);    end        % convert to meter units (lowercase in meters);    dx = modelParams.Dx/1000;  % MMKline: added dx and dy here 07/2024. Needed for alpha and beta below     dy = modelParams.Dy/1000;     dz = modelParams.Dz/1000;         % Preallocate memory of 3D variables used later inside slice 'for' loop for speed; also make single precision.    % These 3D variables used later in calculations or debugging, but some variables are 2D to save memory.      Z = zeros(size(modelParams.Modl),'single');           % acoustic  impedance; needed for ARFI and Q calculation (could recalc).    Refl = zeros(size(modelParams.Modl),'single');        % reflection coefficient; saved for backward wave calculation (could recalc).    sqrtexpon = zeros(size(modelParams.Modl),'single');   % sqrt(1-alpha_sqr-beta_sqr); used in transf, r and rp.    transf = zeros(size(modelParams.Modl),'single');      % transfer function; needed for backward wave propagation.    Aprime = zeros(size(modelParams.Modl),'single');      % angular spectra; used for debugging with pout=Aprime (could make matrix)    pfor = zeros(size(modelParams.Modl),'single');        % pressure array, forward propagation.    pfortot = zeros(size(modelParams.Modl),'single');     % initialize accumulated pressure array, forward propagation.    pref = zeros(size(modelParams.Modl),'single');        % back reflection    pbacktot = zeros(size(modelParams.Modl),'single');    % initialize accumulated pressure array, back propagation.    bprime = zeros(1,nmax);                               % vector of mean propagation coefficient.        %% main calculation ============================================================================        tic % time the computation        % ----- This section handles the generalized ERFA calculations ----    if erfaParams.isPA  %  phased array?  If so, apply optional steering or phase correction angles.        % multiply perfa pages by steering phases or phase-correction phases and sum.        angarr = repmat(single(positioningParams.angpgvect),[lmaxerfa,mmaxerfa,1]);        serfa = sum(erfaParams.perfa.*angarr,3);  % summed perfa (single page).        serfa = serfa*sqrt(erfaParams.Pr);        % adjust for total radiated power since perfa normalized to 1 W.        clear angarr % to free memory.    else        serfa = erfaParams.perfa*sqrt(erfaParams.Pr);   % solid transducer, so no need to consider phase.  Adjust power as above.    end      clear erfaParams.perfa; % to free memory    hwb = waitbar(0,'INITIALIZING','Name','Initializing');         % Interpolate summed erfa onto smaller grid to match pp. Note conj to account for R-S.       % Custom interp code that more correctly interpolates complex matrices such as    % pressure waves than does interp2.  Uses normalized input matrix to find accurate phase angles.      % xaxiserfaoffs, xaxisinterp are row vectors; yaxiserfaoffs, yaxisinterp are col. vectors.    if min(serfa(:)) == 0        zia = interp2(xaxiserfaoffs,yaxiserfaoffs,serfa,xaxisinterp,yaxisinterp','*linear',0);              % to avoid 0/0    else        zia = interp2(xaxiserfaoffs,yaxiserfaoffs,serfa./abs(serfa),xaxisinterp,yaxisinterp','*linear',0);  % normalized serfa here only    end    za = angle(zia);  % in radians    zm = interp2(xaxiserfaoffs,yaxiserfaoffs,abs(serfa),xaxisinterp,yaxisinterp','*linear',0);    ppe = conj(zm.*exp(1i*za));             % distance to propagate from ERFA plane to front of modelParams.Modl; okay to be negative.    emdist = (positioningParams.dmm/1000)-erfaParams.sx;  % note conversion of dmm to meters    if emdist ~= 0 % only do translation to new distance if emdist is not zero:        % These next lines change the distance from the ERFA plane to front face of modelParams.Modl, depending on gui input.            % Note that mmax is the max x index, lx is the extent of model in x in meters, and bprime is the mean            % propagation constant.        ferfa = fftshift(fft2(ppe));          % into freq domain to allow propagation to a different distance between ERFA and model.        bprimeerfa = 2*pi*f/modelParams.c0;   % region in front of modelParams.Modl is water, so mean bprime = omega/modelParams.c0.        % 07/2024: correct frequency scaling and allow even model sizes                alpha = ((1:mmax)-ceil((mmax+1)/2))*(2*pi/(bprimeerfa*mmax*dx));   % vector of alpha in water (so use bprimeerfa). 07/22/2024        beta = ((1:lmax)-ceil((lmax+1)/2))*(2*pi/(bprimeerfa*lmax*dy));    % vector of beta in water. 07/22/2024        [alpha_sq,  beta_sq] = meshgrid(alpha.^2, beta.^2);     % lmax by mmax matrices for water transfer function.        % inside sqrt part of exponent in transfer function below. When expon neg,          % evanescent waves will decay for positive emdist, but will blow up in the backward direction for negative        % emdist. So the next lines filter out those evanescent waves. (Note: Since the direction cosines alpha =        % fx times lambda and beta = fy times lambda, alpha and beta can be > 1 for high spatial frequencies caused        % by spatial details that are < lambda. Then 1 - alpha_sq - beta_sq will be negative and transfer function will        % result in decaying expon waves for positive emdist, but increasing waves for neg emdist.)        expon=1 - alpha_sq - beta_sq;           if emdist < 0            transferfa = zeros(lmax,mmax);            ind2 = find(expon > 0);            transferfa(ind2) = exp(1i*bprimeerfa*emdist*sqrt(expon(ind2)));        else            transferfa = exp(1i*bprimeerfa*emdist*sqrt(expon));        end        pp = ifft2(ifftshift(ferfa.*transferfa));  % pressure matrix at front face of model.    else        pp = ppe;    end        waitbar(0.5)    % --------- Approach C to model scattering; this assumes random variation > voxel size -----------------    if max(modelParams.randvc) ~= 0   % do next lines only if there will be scattering due to non-zero std dev of parameters.    % The next lines can modify pprimeterm such that there is random spatial variation in overall propagation in space:        rrandcrs = 1:corrl:lmax+corrl; % rrandcrs is a course row (vector) grid for the random parameter variation, etc,        crandcrs = 1:corrl:mmax+corrl; % where corrl is correlation length (in indices) of the random variation.        prandcrs = 1:corrl:nmax+corrl;        randarrcrs = ones(length(rrandcrs),length(crandcrs),length(prandcrs)); % make a course grid array, spacing = corrl.        randarrcrs = single(randn(size(randarrcrs)));         % array now contains normal random numbers: mean = 0, std dev = 1.        [cfine,rfine,pfine] = meshgrid(1:mmax,1:lmax,1:nmax); % define indices of final finer array of random numbers.        randarrfine = interp3(crandcrs,rrandcrs,prandcrs,randarrcrs,cfine,rfine,pfine,'*linear'); %interp to finer array.        vararray = abs(1+modelParams.randvc(modelParams.Modl).*randarrfine); % array of random variation around 1, never negative due to abs.    else        vararray = ones(size(modelParams.Modl),'single'); % if no scattering.    end    % -----------------        waitbar(1)        % Set up values for (virtual) layer 0 -- assume water in region in front of modl.    A0 = fftshift(fft2(pp));              % pp is pressure pattern on front plane of modl.    Z0 = modelParams.rho0*modelParams.c0; % impedance of water.        close(hwb)        %  ======== Start of Multiple Reflection 'for' loop ===============================    reflectionNum = 0;   % number indicating what reflection is being done in multiple reflections.    for loop = 1:1:(numrefl/2) +1                %----- Start of forward increment in layerNum ( + z propagation direction) -------------        hwb1 = waitbar(0,['Calculating Forward Propagation -----> Reflection #', num2str(reflectionNum)]);                 for layerNum = 1:nmax            if reflectionNum == 0                 % Set up 2D acoustic property matrices (to save memory) for this particular plane:                attmodl = modelParams.a(:,:,layerNum)*1e2*erfaParams.fMHz;     % modelParams.a(i) is pressure total attenuation coefficient (assume linear freq dep).                rhomodl = modelParams.rho(:,:,layerNum);    % modelParams.rho is density.                b = 2*pi*f./modelParams.c(:,:,layerNum);    % 2D matrix of propagation constant.                Z(:,:,layerNum) = rhomodl.*modelParams.c(:,:,layerNum).*(1-1i*attmodl./b);  % impedance of layer layerNum (slightly complex-be careful in P calcs).                if layerNum == 1                    Refl(:,:,1) = (Z(:,:,1) - Z0)./(Z(:,:,1) + Z0);   % layer 1 exception.                    pforb = pp.*(1+Refl(:,:,1));   % pforb due to source pressure pattern pp.                else                    Refl(:,:,layerNum)=(Z(:,:,layerNum) - Z(:,:,layerNum-1))./(Z(:,:,layerNum) + Z(:,:,layerNum-1));  % pressure reflection coeficient from layer layerNum.                    pref(:,:,layerNum-1)=Refl(:,:,layerNum).*pfor(:,:,layerNum-1);   % reflected pressure from forward propagation.                    pforb=pfor(:,:,layerNum-1).*(1+Refl(:,:,layerNum));                end                bprime(layerNum) = sum(sum(abs(pforb).*b))./sum(sum(abs(pforb)));    % mean propagation constant,                % averaged over entire plane area, weighted by expected beam region.                % 07/2024: correct frequency scaling and allow even model sizes                alpha = ((1:mmax)-ceil((mmax+1)/2))*(2*pi/(bprime(layerNum)*mmax*dx));   % vector of alpha for this layer. 07/22/2024                beta = ((1:lmax)-ceil((lmax+1)/2))*(2*pi/(bprime(layerNum)*lmax*dy));    % vector of beta. See earlier comments on alpha, beta. 07/22/2024                [alpha_sq,  beta_sq] = meshgrid(alpha.^2, beta.^2);             % lmax by mmax matrices for transfer function (and r, rp).                sqrtexpon(:,:,layerNum) = sqrt(1 - alpha_sq - beta_sq);         % sqrt part of exponent in transfer function and in r, rp below.                % even if it is imag when arg negative, evanescent waves will decay since bprime and dz always pos                transf(:,:,layerNum) = exp(1i*bprime(layerNum).*dz.*sqrtexpon(:,:,layerNum));            else                  A0=ones(size(pp));                if layerNum == 1   % layer 1 exception                    pforb = pref2(:,:,1);                else                    pref(:,:,layerNum-1) = Refl(:,:,layerNum).*pfor(:,:,layerNum-1);   % reflected pressure from forward propagation.                    pforb = pfor(:,:,layerNum-1).*(1+Refl(:,:,layerNum)) + pref2(:,:,layerNum);                end            end                           % use full integration (equations from Scott Almquist):            r = dz./sqrtexpon(:,:,layerNum);     % oblique path length as function of cos of angles (alpha, beta).            rp = dz.*sqrtexpon(:,:,layerNum);    % phase path length as function of cos of angles (alpha, beta).            complex_idx = imag(rp) > 0;               r(complex_idx) = 0;           % to avoid exp increasing when r's are complex and dbvect is neg.            rp(complex_idx) = 0;          % to avoid exp increasing when rp's are complex and dbvect is neg.            if layerNum == 1 || sum(sum(abs(A))) == 0                Aabs = abs(A0);            else                Aabs = abs(A);            end            Aabs(Aabs<0.5*max(Aabs(:))) = 0;            Asum = sum(Aabs(:));            rave = sum(sum(r.*Aabs))/Asum;            rpave = sum(sum(rp.*Aabs))/Asum;                        bvect = 2*pi*f./modelParams.c(:,:,layerNum);   % propagation constant matrix; (units 1/m).            avect = modelParams.a(:,:,layerNum)*1e-4*f;    % attenuation matrix; (units Np/m) (linear freq dep).            dbvect = bvect - bprime(layerNum);             % excess of media prop constant over mean prop constant (bprime); can be neg.                        % These next lines do full numerical integration of the exponential propagation in the            % space domain, weighted by A (see Eq. 4, Working Notes1, 5/8/06, revised 4/29/16).            % cast pprimeterm to double to be consistent with CalcHAS_ERFA8f, which preallocates with NaN            pprimeterm=double(exp(1i*dbvect.*rpave).* exp(-avect.*rave));            pprime=pforb.*pprimeterm.*vararray(:,:,layerNum); % space-domain effects; vary by random amt (Approach C).            Aprime(:,:,layerNum) = single(fftshift(fft2(pprime)));	% complex Eq (8); wraparound fft.            A = Aprime(:,:,layerNum).*transf(:,:,layerNum);	   % Eq (9rev).            pmat = single(ifft2(ifftshift(A)));	  % Eq (10).            pfor(:,:,layerNum) = pmat;                        waitbar(layerNum/nmax)        end        % --------- end of forward propagation --------------------------                close(hwb1);        reflectionNum = reflectionNum+1;        pfortot = pfortot + pfor;  % accumulate pfor; could also add at each layerNum slice to eliminate pfor array for memory savings.                if reflectionNum == numrefl + 1       % branch out of loop if next backward propagation not needed.            break        end                %------------ Start of backward increment in layerNum (slice number) ( - z propagation direction) -------------        hwb2 = waitbar(1,['<----- Calculating Backward Propagation, Reflection #', num2str(reflectionNum)]);                pback = zeros(size(modelParams.Modl),'single');         % pressure array, back propagation        Aprimeback = zeros(size(modelParams.Modl),'single');    % see Aprime.        pref2 = zeros(size(modelParams.Modl),'single');         % forward reflection        pback(:,:,nmax) = 0;                                    % set up conditions for nmax layer        A=0;                for layerNum=(nmax-1):-1:1     % start at nmax-1 since pref=0 at last boundary.            % note neg Refl since in opposite direction; Refl calculated earlier.            pbackb=pback(:,:,layerNum+1).*(1-Refl(:,:,layerNum+1)) + pref(:,:,layerNum);  % add transmitted backward wave to reflected wave.                        % use full integration. Assume that bprime(layerNum) is the same as in forward increments (so sqrtexpon same):            r = dz./sqrtexpon(:,:,layerNum);    % oblique path length as function of cos of angles (alpha, beta).            rp = dz.*sqrtexpon(:,:,layerNum);   % phase path length as function of cos of angles (alpha, beta).            complex_idx = imag(rp) > 0;            rp(complex_idx) = 0;            r(complex_idx) = 0;                 % to avoid exp increasing when r's are complex and dbvect is neg.                        if layerNum==nmax-1 || sum(sum(abs(A)))==0                Aabs(:) = 1;            else                Aabs=abs(A);            end            Aabs(Aabs<0.5*max(Aabs(:))) = 0;            Asum = sum(Aabs(:));            rave = sum(sum(r.*Aabs))/Asum;            rpave = sum(sum(rp.*Aabs))/Asum;                              bvect = 2*pi*f./modelParams.c(:,:,layerNum);    % propagation constant matrix; (units 1/m).            avect = modelParams.a(:,:,layerNum)*1e-4*f;     % attenuation matrix; (units Np/m) (linear freq dep).                     dbvect = bvect - bprime(layerNum);              % excess of media prop constant over mean prop constant (bprime); can be neg.                                  % These next lines do full numerical integration of the exponential propagation in the            % space domain, weighted by A (see Eq. 4, Working Notes1, 5/8/06, revised 4/29/16).            pprimeterm = double(exp(1i*dbvect.*rpave).*exp(-avect.*rave));            pbackprime = pbackb.*pprimeterm.*vararray(:,:,layerNum);     % backward prop in space domain.            Aprimeback(:,:,layerNum) = single(fftshift(fft2(pbackprime)));	  % complex Eq (8); wraparound fft.            A = Aprimeback(:,:,layerNum).*transf(:,:,layerNum);	    % Eq (9rev) in reverse direction.            pmat = single(ifft2(ifftshift(A)));	% Eq (10).            pback(:,:,layerNum) = pmat;            pref2(:,:,layerNum) = -Refl(:,:,layerNum).*pback(:,:,layerNum);    % note negative Refl since in opposite direction.                        waitbar(layerNum/nmax)                    end        % ------- End of backward propagation -----------------                close(hwb2);                reflectionNum = reflectionNum +1;   % get ready for next loop        pbacktot = pbacktot + pback;    end     % ================ End of Multiple Reflection 'for' loop ======================    ptot = pfortot+pbacktot;                % complex add forward and backward waves.    Q = real(absmodl.*ptot.*conj(ptot./Z)); % power deposition for complex ptot and Z; now use ONLY abs coefficient.    maxQ = max(Q(:));    pout = ptot;          maxpout = max(abs(pout(:)));     tocend % function calcHAS()